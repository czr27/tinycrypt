; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\cryptarm\xoodoo\xoodoo4.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_xoodoo
; Function compile flags: /Ogspy
; File c:\hub\cryptarm\xoodoo\xoodoo4.c
;	COMDAT _xoodoo
_TEXT	SEGMENT
_rc$ = -64						; size = 48
_e3$ = -16						; size = 4
tv1004 = -12						; size = 4
_e2$ = -8						; size = 4
_r$ = -4						; size = 4
_e1$ = 8						; size = 4
_state$ = 8						; size = 4
_xoodoo	PROC						; COMDAT

; 32   : void xoodoo(void *state) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 33   :     uint32_t e[4], x0, x1, x2, x3, t;
; 34   :     uint32_t e0, e1, e2, e3;
; 35   :     int      r, i;
; 36   :     uint32_t *x=(uint32_t*)state;
; 37   : 
; 38   :     uint32_t rc[12]=
; 39   :     { 0x058, 0x038, 0x3c0, 0x0d0,
; 40   :       0x120, 0x014, 0x060, 0x02c,
; 41   :       0x380, 0x0f0, 0x1a0, 0x012 };
; 42   : 
; 43   :     // 12 rounds by default
; 44   :     for (r=0; r<12; r++) {

	and	DWORD PTR _r$[ebp], 0
	mov	eax, DWORD PTR _state$[ebp]
	push	ebx
	push	esi
	mov	DWORD PTR _rc$[ebp], 88			; 00000058H
	mov	DWORD PTR _rc$[ebp+4], 56		; 00000038H
	mov	DWORD PTR _rc$[ebp+8], 960		; 000003c0H
	mov	DWORD PTR _rc$[ebp+12], 208		; 000000d0H
	mov	DWORD PTR _rc$[ebp+16], 288		; 00000120H
	mov	DWORD PTR _rc$[ebp+20], 20		; 00000014H
	mov	DWORD PTR _rc$[ebp+24], 96		; 00000060H
	mov	DWORD PTR _rc$[ebp+28], 44		; 0000002cH
	mov	DWORD PTR _rc$[ebp+32], 896		; 00000380H
	mov	DWORD PTR _rc$[ebp+36], 240		; 000000f0H
	mov	DWORD PTR _rc$[ebp+40], 416		; 000001a0H
	mov	DWORD PTR _rc$[ebp+44], 18		; 00000012H
	push	edi
$LL23@xoodoo:

; 45   :       // Theta
; 46   :       for (i=0; i<4; i++) {

	push	4
	lea	esi, DWORD PTR [eax+16]
	pop	ebx
$LL9@xoodoo:

; 47   :         e0 = ROTR32(x[i] ^ x[i+4] ^ x[i+8], 18);

	mov	ecx, DWORD PTR [esi-16]
	xor	ecx, DWORD PTR [esi+16]

; 48   :         e0^= ROTR32(e0, 9);
; 49   :         
; 50   :         XCHG(e0, e1);

	mov	edi, DWORD PTR _e1$[ebp]
	xor	ecx, DWORD PTR [esi]
	add	esi, 4
	rol	ecx, 14					; 0000000eH
	mov	edx, ecx
	ror	edx, 9
	xor	edx, ecx
	dec	ebx

; 51   :         XCHG(e1, e2);

	mov	ecx, DWORD PTR _e2$[ebp]
	mov	DWORD PTR _e1$[ebp], ecx

; 52   :         XCHG(e2, e3);

	mov	ecx, DWORD PTR _e3$[ebp]
	mov	DWORD PTR _e2$[ebp], ecx
	mov	DWORD PTR _e3$[ebp], edx
	jne	SHORT $LL9@xoodoo

; 53   :       }
; 54   : 
; 55   :       for (i=0; i<12; i+=4) {

	push	3
	lea	ecx, DWORD PTR [eax+8]
	pop	esi
$LL6@xoodoo:

; 56   :         x[i+0] ^= e3; x[i+1] ^= e0;
; 57   :         x[i+2] ^= e1; x[i+3] ^= e2;        

	mov	ebx, DWORD PTR _e1$[ebp]
	xor	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR _e2$[ebp]
	xor	DWORD PTR [ecx-8], edx
	xor	DWORD PTR [ecx-4], edi
	xor	DWORD PTR [ecx+4], ebx
	add	ecx, 16					; 00000010H
	dec	esi
	jne	SHORT $LL6@xoodoo

; 58   :       }
; 59   : 
; 60   :       // Rho west
; 61   :       XCHG(x[7], x[4]);

	mov	edx, DWORD PTR [eax+28]
	lea	ecx, DWORD PTR [eax+16]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], edx

; 62   :       XCHG(x[7], x[5]);

	mov	edx, esi
	mov	esi, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+20], edx

; 63   :       XCHG(x[7], x[6]);

	mov	edx, esi
	mov	esi, DWORD PTR [eax+24]
	mov	DWORD PTR [eax+24], edx

; 64   : 
; 65   :       // Iota
; 66   :       x[0] ^= rc[r];

	mov	edx, DWORD PTR _r$[ebp]
	mov	edx, DWORD PTR _rc$[ebp+edx*4]
	xor	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+28], esi
	mov	DWORD PTR tv1004[ebp], 4
$LL3@xoodoo:

; 67   : 
; 68   :       // Chi and Rho east
; 69   :       for (i=0; i<4; i++) {
; 70   :         x0 = x[i+0];

	mov	edi, DWORD PTR [ecx-16]

; 71   :         x1 = x[i+4];

	mov	edx, DWORD PTR [ecx]

; 72   :         x2 = ROTR32(x[i+8], 21);

	mov	esi, DWORD PTR [ecx+16]
	rol	esi, 11					; 0000000bH

; 73   : 
; 74   :         x[i+8] = ROTR32((~x0 & x1) ^ x2, 24);

	mov	ebx, edi
	not	ebx
	and	ebx, edx
	xor	ebx, esi
	rol	ebx, 8
	mov	DWORD PTR [ecx+16], ebx

; 75   :         x[i+4] = ROTR32((~x2 & x0) ^ x1, 31);

	mov	ebx, esi
	not	ebx
	and	ebx, edi
	xor	ebx, edx

; 76   :         x[i+0]^= ~x1 & x2;

	not	edx
	and	edx, esi
	xor	edx, edi
	rol	ebx, 1
	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx-16], edx
	add	ecx, 4
	dec	DWORD PTR tv1004[ebp]
	jne	SHORT $LL3@xoodoo

; 77   :       }
; 78   :       XCHG(x[8], x[10]);

	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+40]
	inc	DWORD PTR _r$[ebp]
	cmp	DWORD PTR _r$[ebp], 12			; 0000000cH
	mov	DWORD PTR [eax+32], edx

; 79   :       XCHG(x[9], x[11]);

	mov	edx, DWORD PTR [eax+44]
	mov	DWORD PTR [eax+40], ecx
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [eax+36], edx
	mov	DWORD PTR [eax+44], ecx
	jl	$LL23@xoodoo
	pop	edi
	pop	esi
	pop	ebx

; 80   :     }
; 81   : }

	leave
	ret	0
_xoodoo	ENDP
_TEXT	ENDS
END
